# RISC-V架构下，浮点指令在整数寄存器中的实现机制

### Zfinx/Zdinx/Zhinx/Zhinxmin 扩展

仝嘉成 2026年 1月 21日

---

## 重新定义浮点实现的技术背景
### 传统浮点扩展优缺点
RISC-V 传统浮点扩展（F/D）依赖独立 f 寄存器文件
- 优点： 减少整数寄存器压力，便于超标量设计  
- 缺点： 增加硬件复杂度与面积成本， 最小实现成本变大  
F扩展使用单独的F寄存器进行浮点计算，以降低寄存器压力并为超标量提供寄存器堆端口。然而，额外的架构状态增加了最小的实现成本。
#### 减少寄存器压力
“寄存器压力”指的是在某段程序中，活跃变量数量接近或超过可用寄存器数量的程度。寄存器压力过大会导致编译器频繁“溢出”（spill）到内存中，降低性能。
使用独立的 F 寄存器文件， 浮点寄存器专门用于浮点计算, 整数寄存器专门用于整型计算, 两者互不干扰， 寄存器压力显著降低。
#### 便于超标量设计
超标量（Superscalar）架构 指的是处理器在一个时钟周期内能同时发射多条指令到多个执行单元，从而实现指令级并行。
在使用 F 寄存器的情况下， 由于寄存器结构的独立性， 整数单元访问 x 寄存器文件， 浮点单元访问 f 寄存器文件， 两者可以同时取数/写回，不发生端口争用。这也意味着， 指令调度逻辑可以将整数和浮点操作并行发射， 例如一条整数加法与一条浮点乘法可并行执行。
#### 额外的架构状态
拥有两套寄存器文件意味着：需要在硬件中 额外实现 32 个 32 位（或 64 位）寄存器 , 同时还要维护与之相关的状态寄存器，如  fcsr （浮点控制和状态寄存器）。另外需要额外的读写端口和额外的译码与控制逻辑。
这就造成了： 更多的硬件资源占用 （面积、功耗、时钟树布线、端口数）， 更复杂的上下文管理机制 （因为操作系统要保存/恢复两组寄存器）。
在 简单或低端处理器 中，面积和功耗预算极其有限,即使寄存器文件不大，它也带来了一定的不可忽略的硬件负担。其在小核心上可能占到核心面积的数个百分点。
因此，对没有复杂流水线或多发射能力的简单 RISC-V 核心而言，浮点寄存器堆是一个相对昂贵的模块。

---

## Zfinx 系列扩展设计目标
- 在  不引入 f 寄存器  的情况下实现浮点计算  
- 浮点操作直接使用  x 寄存器  
- 降低实现成本, 简化上下文切换  
#### 降低实现成本
由于Zfinx 的核心思路是复用现有整数寄存器文件来执行浮点计算，完全去除独立的 f 寄存器堆,
这种设计带来了直接的硬件简化，包括仅保留一套寄存器文件， 不再需要额外的时钟树与端口， 浮点运算单元（FPU）直接从整数寄存器读取与写回数据， 实现逻辑显著简化。
其带来的结果是：芯片面积减少， 功耗降低，时钟设计更容易。
#### 简化上下文切换
由于 Zfinx 取消了独立的 f 寄存器文件，浮点运算结果直接存放在  x 寄存器组 中。操作系统只需在任务切换时保存一套寄存器状态,不需要单独设计浮点状态保存逻辑,也不再需要 fcsr 相关的上下文管理机制。使调度过程显著简化。

---

#### F 与 Zdinx 扩展对比表

| 维度    | 传统 F 扩展       | Zfinx 扩展     |
| ----- | ------------- | ------------ |
| 硬件资源  | 独立 f 寄存器文件    | 复用 x 寄存器     |
| 芯片面积  | 较大            | 显著减小         |
| 功耗    | 较高            | 更低           |
| 设计复杂度 | 高（需额外控制与时钟网络） | 低（单寄存器体系）    |
| 上下文切换 | 需保存两套寄存器      | 仅保存一套        |
| 内存占用  | 增加 256–512B   | 减少约一半        |
| 适用场景  | 高性能核、超标量CPU   | 嵌入式核、IoT、MCU |

---

## Zfinx/Zdinx/Zhinx/Zhinxmin 概览
四个扩展的体系结构关系
| 扩展名称     | 浮点精度        | 依赖关系  | 对应标准扩展 | 特点         |
| -------- | ----------- | ----- | ------ | ---------- |
| Zfinx    | 单精度（32-bit） | Zicsr | F      | 基础实现       |
| Zdinx    | 双精度（64-bit） | Zfinx | D      | 双寄存器支持     |
| Zhinx    | 半精度（16-bit） | Zfinx | Zfh    | 轻量实现       |
| Zhinxmin | 半精度（16-bit） | Zfinx | Zfh    | 最小化，仅含转换指令 |

---

## Zfinx 核心机制: 用 X 寄存器代替 F 寄存器
- 指令语义与 F 扩展保持一致  
- 所有访问 f 寄存器的指令 → 改为访问相同编号的 x 寄存器  
- 省略的指令：FLW, FSW, FMV.W.X, FMV.X.W, 压缩型 C.FLW[SP], C.FSW[SP].
Zfinx扩展添加了F扩展添加的所有指令，但传输指令除外。
Zfinx扩展依赖于“Zicsr”扩展来访问控制和状态寄存器。

---

### F 与Zfinx 指令对比
代码来自riscv-isa-sim
```c++
  // disasm/disasm.cc
  // 对比 F 扩展与 Zfinx 扩展中的指令
  // F 扩展所独有
  if (ext_enabled('F')) {
    DEFINE_FLOAD(flw)
    DEFINE_FSTORE(fsw)
    DEFINE_XFTYPE(fmv_w_x);
    DEFINE_FXTYPE(fmv_x_w);
  }

  // F 扩展与 Zdinx扩展所共有
  if (ext_enabled('F') || ext_enabled(EXT_ZFINX)) {
    DEFINE_FRTYPE(fadd_s);
    DEFINE_FRTYPE(fsub_s);
    DEFINE_FRTYPE(fmul_s);
    DEFINE_FRTYPE(fdiv_s);
    DEFINE_FR1TYPE(fsqrt_s);
    DEFINE_FRTYPE(fmin_s);
    DEFINE_FRTYPE(fmax_s);
    DEFINE_FR3TYPE(fmadd_s);
    DEFINE_FR3TYPE(fmsub_s);
    DEFINE_FR3TYPE(fnmadd_s);
    DEFINE_FR3TYPE(fnmsub_s);
    DEFINE_FRTYPE(fsgnj_s);
    DEFINE_FRTYPE(fsgnjn_s);
    DEFINE_FRTYPE(fsgnjx_s);
    DEFINE_FR1TYPE(fcvt_s_d);
    DEFINE_FR1TYPE(fcvt_s_q);
    DEFINE_XFTYPE(fcvt_s_w);
    DEFINE_XFTYPE(fcvt_s_wu);
    DEFINE_XFTYPE(fcvt_s_wu);
    DEFINE_FXTYPE(fcvt_w_s);
    DEFINE_FXTYPE(fcvt_wu_s);
    DEFINE_FXTYPE(fclass_s);
    DEFINE_FX2TYPE(feq_s);
    DEFINE_FX2TYPE(flt_s);
    DEFINE_FX2TYPE(fle_s);

    // 如果是RV64架构， 才会定义下面的类型转换指令
    if (xlen_eq(64)) {
      DEFINE_XFTYPE(fcvt_s_l);
      DEFINE_XFTYPE(fcvt_s_lu);
      DEFINE_FXTYPE(fcvt_l_s);
      DEFINE_FXTYPE(fcvt_lu_s);
    }
  }
```

---

## Zdinx
Zdinx 扩展 提供与标准 D 扩展 对应的双精度浮点指令集，并依赖 Zfinx 扩展。
它包含 D 扩展中的所有双精度运算指令，但不包括寄存器与内存、整数寄存器之间的数据传输指令（即 FLD、FSD、FMV.D.X、FMV.X.D 以及压缩形式 C.FLD[SP]、C.FSD[SP]）。
在 Zdinx 中，这些指令的语义保持与 D 扩展一致，只是所有对 f 寄存器的访问均被替换为对同编号 x 寄存器的访问。

#### 宽值处理
在 RV32 Zdinx 架构中，双精度（64 位）浮点操作数存放在成对对齐的整数寄存器中，即寄存器编号必须为偶数。
奇数编号寄存器用于双精度操作数的情况被保留（不可使用）。
无论大小端模式如何，低编号寄存器保存操作数的低 32 位，高编号寄存器保存高 32 位.
例如一个双精度操作数的低 32 位存于 x14，高 32 位存于 x15。
当结果写入 x0 时，整个写操作被忽略，不会影响 x1；当 x0 被用作双宽度浮点操作数时，其值视为全零（不会访问 x1）。
若系统未实现“Load/Store Pair”扩展，RV32Zdinx 需要通过两条加载或存储指令完成双精度数据与内存间的传输。
但寄存器之间的数据移动仍可通过单条 FSGNJ.D 指令完成。

---

## Zhinx
Zhinx 扩展 提供与标准 Zfh 扩展 对应的半精度（16 位）浮点指令集，并以 Zfinx 扩展 为依赖基础。
它包含 Zfh 扩展中的全部半精度浮点运算指令，但不包括寄存器与内存、整数寄存器之间的数据传输指令（即 FLH、FSH、FMV.H.X 和 FMV.X.H）。
在 Zhinx 中，这些指令的语义与 Zfh 保持一致，不同之处在于：所有原本访问 f 寄存器的操作都改为访问同编号的 x 寄存器。

## Zhinxmin
Zhinxmin 扩展 是在 x 寄存器 上实现的最小化半精度（16 位）浮点支持扩展，并以 Zfinx 扩展 为依赖。
它仅从 Zhinx 扩展 中引入必要的类型转换指令：FCVT.S.H 与 FCVT.H.S；若系统同时实现 Zdinx 扩展，则还包含 FCVT.D.H 与 FCVT.H.D。
Zhinxmin 的目标是为需要基本半精度与单/双精度转换功能的系统提供轻量化支持，而无需完整的半精度运算单元。

#### 窄值处理
在 Zfinx 架构中，浮点操作数直接存放于整数寄存器中。
对于宽度小于 XLEN 的浮点数（如RV32下的 16 位或RV64下的 32 位），其位模式占据寄存器的低位区间（bits w - 1:0），而高位（bits XLEN - 1:w）在运算时被忽略。
当浮点运算生成 w 位结果时，结果的符号位（bit w-1）会被符号扩展填充到寄存器高位，以保持数据一致性。
这种设计取代了传统 F 扩展中为支持“再编码浮点格式”而采用的 NaN boxing 方案。由于 Zfinx 共用整数寄存器存储整数与浮点数，NaN boxing 不再必要。
对于 RV64 架构，在寄存器中符号扩展 32 位浮点数与现有的函数调用约定相兼容（该约定规定在 x 寄存器中传递 32 位浮点数时，高 32 位未定义）。为保持体系结构一致性，这一符号扩展规则同样适用于 16 位浮点数，并在 RV32 与 RV64 上统一执行。

---

## FPU代码示例
以下通过riscv-isa--sim 的代码，了解浮点处理单元对 Zfinx 扩展的使用
```c++
// riscv/decode_macros.h
// FPU macros
#define READ_ZDINX_REG(reg) (xlen == 32 ? f64(READ_REG_PAIR(reg)) : f64(STATE.XPR[reg] & (uint64_t)-1))
#define READ_FREG_H(reg) (p->extension_enabled(EXT_ZFINX) ? f16(STATE.XPR[reg] & (uint16_t)-1) : f16(READ_FREG(reg)))
#define READ_FREG_BF(reg) (p->extension_enabled(EXT_ZFINX) ? bf16(STATE.XPR[reg] & (uint16_t)-1) : bf16(READ_FREG(reg)))
#define READ_FREG_F(reg) (p->extension_enabled(EXT_ZFINX) ? f32(STATE.XPR[reg] & (uint32_t)-1) : f32(READ_FREG(reg)))
#define READ_FREG_D(reg) (p->extension_enabled(EXT_ZFINX) ? READ_ZDINX_REG(reg) : f64(READ_FREG(reg)))
#define FRS1 READ_FREG(insn.rs1())
#define FRS2 READ_FREG(insn.rs2())
#define FRS3 READ_FREG(insn.rs3())
#define FRS1_H READ_FREG_H(insn.rs1())
#define FRS1_BF READ_FREG_BF(insn.rs1())
#define FRS1_F READ_FREG_F(insn.rs1())
#define FRS1_D READ_FREG_D(insn.rs1())
#define FRS2_H READ_FREG_H(insn.rs2())
#define FRS2_F READ_FREG_F(insn.rs2())
#define FRS2_D READ_FREG_D(insn.rs2())
#define FRS3_H READ_FREG_H(insn.rs3())
#define FRS3_F READ_FREG_F(insn.rs3())
#define FRS3_D READ_FREG_D(insn.rs3())
#define dirty_fp_state  STATE.sstatus->dirty(SSTATUS_FS)
#define dirty_ext_state STATE.sstatus->dirty(SSTATUS_XS)
#define dirty_vs_state  STATE.sstatus->dirty(SSTATUS_VS)
#define DO_WRITE_FREG(reg, value) (STATE.FPR.write(reg, value), dirty_fp_state)
#define WRITE_FRD(value) WRITE_FREG(insn.rd(), value)
#define WRITE_FRD_H(value) \
do { \
  if (p->extension_enabled(EXT_ZFINX)) \
    WRITE_REG(insn.rd(), sext_xlen((int16_t)((value).v))); \
  else { \
    WRITE_FRD(value); \
  } \
} while (0)
#define WRITE_FRD_BF WRITE_FRD_H
#define WRITE_FRD_F(value) \
do { \
  if (p->extension_enabled(EXT_ZFINX)) \
    WRITE_REG(insn.rd(), sext_xlen((value).v)); \
  else { \
    WRITE_FRD(value); \
  } \
} while (0)
#define WRITE_FRD_D(value) \
do { \
  if (p->extension_enabled(EXT_ZFINX)) { \
    if (xlen == 32) { \
      WRITE_RD_PAIR((value).v); \
    } else { \
      WRITE_REG(insn.rd(), (value).v); \
    } \
  } else { \
    WRITE_FRD(value); \
  } \
} while (0)
 ```

---

## Zfinx 系列扩展的特权架构影响
在实现 Zfinx/Zhinx/Zdinx 扩展的系统中，由于浮点运算直接使用整数寄存器文件，不再存在独立的浮点寄存器组，因此对特权架构产生以下影响：
- mstatus.FS 字段被固定为 0，表示系统无独立浮点单元；同时，FS 字段不再影响浮点指令或 fcsr 访问的异常行为。
- misa 寄存器中的 F、D、Q 位（分别对应单精度、双精度与四精度浮点扩展）均被硬连为 0，因为这些扩展不依赖传统 FPU，而通过 Zfinx 系列扩展实现。
- 当前架构中尚无标准方式检测 Zfinx/Zhinx/Zdinx 的存在，未来规范可能引入新的**扩展可发现机制（discoverability mechanism）**以供软件探测。

---
