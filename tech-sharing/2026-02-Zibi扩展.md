# Zibi extension

## Zibi的提出背景
在实际应用中，与常量进行比较的条件分支具有极高的通用性。由于当前 RISC-V ISA 只支持寄存器之间的条件分支，在分支之前必须先将立即数加载到寄存器中，这会增加寄存器压力，并可能导致寄存器溢出和重加载。
注意：
现有的 RISC-V 条件分支指令（如 beq、bne）都要求进行两个寄存器之间的比较。加载立即数会引入不必要的“加载立即数”操作（例如：li a4,5; bne a5,a4,offset），在寄存器资源紧张的情况下还可能发生寄存器溢出/重加载。
基于对 LLVM 编译器的评估，Zibi 在使用带立即数的分支时，可以减少寄存器溢出与重加载，并降低动态指令数量，从而暴露了当前设计中的低效之处。

---

## Zibi 指令及其格式
Zibi 扩展定义了两条指令：BEQI 和 BNEI。
BEQI 和 BNEI 将一个寄存器与一个立即数进行比较，当源寄存器 rs1 与常量立即数 cimm 相等或不相等时分别进行分支。
BEQI 和 BNEI 采用与条件分支相同的 B 型指令格式。12 位的 B 型立即数以 2 字节为单位编码有符号偏移量。该偏移量会进行符号扩展，并加到分支指令地址上以得到目标地址，分支范围为 ±4 KiB。字段 cimm 是用于与源寄存器进行比较的常量立即数。
（以下为指令格式与字段示意）
- rs1：源寄存器
- cimm：5 位比较立即数
- funct3：
  - BEQI：010
  - BNEI：011
- opcode： 1100011

对通用基准程序的性能分析表明，正立即数出现的频率远高于负立即数。Zibi 扩展将所有 5 位立即数编码为正数，唯一的例外是立即数 0，其被表示为 −1（与立即数 0 的比较可以通过 beq/bne rs1, x0, offset 来实现）。

| 位段（bit） | 字段名       | 位宽 | 含义                                     |
| ------- | --------- | -- | -------------------------------------- |
| [31]    | imm[12]   | 1  | 符号位              |
| [30:25] | imm[10:5] | 6  |                              |
| [24:20] | cimm      | 5  | **比较立即数**（Zibi 新增字段，用于与 rs1 比较）        |
| [19:15] | rs1       | 5  | 源寄存器 1，被比较的寄存器                         |
| [14:12] | funct3    | 3  | 指令功能码：<br>BEQI = `010`<br>BNEI = `011` |
| [11:8]  | imm[4:1]  | 4  |                               |
| [7]     | imm[11]   | 1  |                                |
| [6:0]   | opcode    | 7  | 操作码：`1100011`（BRANCH）                  |

---

## 参考代码
来自sail-riscv
```sail
biop = {BNEI, BEQI}

union clause instruction = BITYPE : (bits(13), bits(5), regidx, biop)

mapping encdec_biop : biop <-> bits(3) = {
  BEQI  <-> 0b010,
  BNEI  <-> 0b011
}

mapping clause encdec = BITYPE(imm @ 0b0, cimm, rs1, op)
  <-> imm[11] @ imm[9..4] @ cimm @ encdec_reg(rs1) @ encdec_biop(op) @ imm[3..0] @ imm[10] @ 0b1100011
  when currentlyEnabled(Ext_Zibi)

$[split op]
function clause execute BITYPE(imm, cimm, rs1, op) = {
  let cimmext : xlenbits = if cimm == zeros() then ones() else zero_extend(cimm);
  let taken : bool = match op {
    BEQI  => X(rs1) == cimmext,
    BNEI  => X(rs1) != cimmext
  };
  if taken
  then jump_to(PC + sign_extend(imm))
  else RETIRE_SUCCESS
}

mapping bitype_mnemonic : biop <-> string = {
  BEQI  <-> "beqi",
  BNEI  <-> "bnei"
}

mapping clause assembly = BITYPE(imm, 0b00000, rs1, op)
  <-> bitype_mnemonic(op) ^ spc() ^ reg_name(rs1) ^ sep() ^ "-1" ^ sep() ^ hex_bits_signed_13(imm)
mapping clause assembly = BITYPE(imm, cimm, rs1, op)
  <-> bitype_mnemonic(op) ^ spc() ^ reg_name(rs1) ^ sep() ^ hex_bits_5(cimm) ^ sep() ^ hex_bits_signed_13(imm)
  when cimm != 0b00000
```
